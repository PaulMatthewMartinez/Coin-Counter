
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module maincontroller(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	output 	reg		   [7:0]		HEX0,
	output		reg	   [7:0]		HEX1,
	//output		     [7:0]		HEX2,
	//output		     [7:0]		HEX3,
	output	reg    [7:0]		HEX4,
	output	reg	     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		reg     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,
	
	output reg  [6:0] balance_c

);


parameter PENNY = 4'b0001;
parameter NICKEL = 4'b0010;
parameter DIME = 4'b0100;
parameter QUARTER = 4'b1000;

parameter INITIAL = 2'b00;
parameter FULL = 2'b01;
parameter ERROR = 2'b10;
parameter ADD = 2'b11;



//=======================================================
//  REG/WIRE declarations
//=======================================================
reg[2:0] state, c_state;
//reg[6:0] balance_c,balance;
//reg[7:0]	seggy0,seggy1;
//reg[5:0] lighty0,lighty1;
reg[6:0]balance;
reg getty99,gotty99;
reg [6:0] coiny;
//=======================================================
//  Structural coding
//=======================================================

bcd2driver bcd2(.HEX0(HEX4[7:0]),.HEX1(HEX5[7:0]),
.coin(balance_c));


   parameter ZERO =  8'b1100_0000;
   parameter ONE =   8'b1111_1001;
	parameter TWO =  8'b1010_0100;
	parameter THREE =  8'b1011_0000;
	parameter FOUR =  8'b1001_1001;
	parameter FIVE =  8'b1001_0010;


reg n;
reg rising_transition;
wire rising_transition_c;
// logic to detect 0 in previous cycle and 1 in current cycle
assign rising_transition_c = ~n & ~KEY[1];
// flip-flop instantiations
always @(posedge MAX10_CLK1_50 ) begin
n <= #1 ~KEY[1];
rising_transition <= #1 rising_transition_c;
balance <= #1 balance_c;
state <= #1 c_state;
end


always@(*)begin
c_state=state;
balance_c=balance;
LEDR[9:0] = 10'b0000000000;
	case(state)
			INITIAL:begin
					c_state = ADD;
				end
			
			ADD:begin
		
						
							if(rising_transition)begin
							case(SW[3:0])
							4'b0001:begin 
							balance_c = balance_c + 7'b000_0001; 
							HEX1=ZERO; HEX0=ONE;
							LEDR[9:0] = 10'b0000000000;
							
							end
							4'b0010:begin 
							balance_c = balance_c + 7'b0000_101;
							HEX1=ZERO; HEX0=FIVE; 
							LEDR[9:0] = 10'b0000000000;
							
							end
							4'b0100:begin 
							balance_c = balance_c + 7'b000_1010;
							HEX1=ONE; HEX0=ZERO;
							LEDR[9:0] = 10'b0000000000;
							
							end
							4'b1000:begin 
							balance_c = balance_c + 7'b001_1001;
							HEX1 = TWO; HEX0 = FIVE;
							LEDR[9:0] = 10'b0000000000;
							
							end
							4'b0000:begin 
							balance_c = balance_c ; 
							HEX1 = ZERO; HEX0 = ZERO;
							LEDR[9:0] = 10'b0000000000;
							end
							default:begin
							HEX1=8'b1011_1111; HEX0=8'b1011_1111; 
							c_state=ERROR;
							end
							endcase
					end
			end
			ERROR:begin
			if(KEY[0]==0)begin
				LEDR[9:0] = 10'b0000000000;
				c_state=INITIAL;
			end
			else begin
				LEDR[9:0] = 10'b0000011111;
				c_state=ERROR;
			end
			end	
	endcase
			

				if (KEY[0] == 0)begin
				c_state=INITIAL;
				balance_c=7'b0000000;
				LEDR[9:0] = 10'b0000000000;
				end
				
				if(balance_c>7'b110_0100)begin
				LEDR=10'b1111100000;
				end
				


end


endmodule
